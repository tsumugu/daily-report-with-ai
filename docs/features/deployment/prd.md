# デプロイ機能 プロダクト要件定義書（PRD）

**ステータス**: Approved

**作成日**: 2025-01-XX  
**作成者**: PdM  
**目的**: Daily Reportプロジェクトのデプロイ機能に関する要求と決定事項の整理

---

## 📋 目次

1. [概要](#概要)
2. [要求事項](#要求事項)
3. [決定事項](#決定事項)
4. [機能要件](#機能要件)
5. [非機能要件](#非機能要件)
6. [制約事項](#制約事項)
7. [成功指標](#成功指標)
8. [バックログ](#バックログ)

---

## 概要

### 目的

Daily Reportプロジェクトを本番環境にデプロイし、以下の要件を満たすこと：

- SQLiteデータの永続化と分離
- CI/CDの自動化
- 従量課金制での運用
- Infrastructure as Codeによる管理

### スコープ

本PRDは以下の範囲を対象とします：

- バックエンド（API）のデプロイ
- フロントエンド（Web）のデプロイ
- データベース（SQLite）の永続化
- CI/CDパイプラインの構築
- インフラ構成の管理

---

## 要求事項

### 必須要件

#### 要件1: SQLiteのデータが飛ばないこと（APIサーバとは別に管理）

**要求内容**:

- SQLiteファイルは永続化ストレージに保存すること
- APIコンテナ/サーバーとは独立したストレージ管理であること
- デプロイ時にデータが失われないこと

**背景**:

- SQLiteはファイルベースのデータベースのため、永続化ストレージが必要
- サーバーレス環境では、コンテナの再起動時にデータが失われるリスクがある

**優先度**: **必須**

---

#### 要件2: CI/CDを適切に構築できること

**要求内容**:

- GitHubでmasterブランチにマージしたら自動的にFE, BEともにデプロイされること
- GitHub Actionsを使用すること

**背景**:

- 手動デプロイは人的ミスのリスクがある
- 自動化により、デプロイの効率化と品質向上を図る

**優先度**: **必須**

---

#### 要件3: 従量課金制であること

**要求内容**:

- 月額固定のVPSは不可
- 有料プランへの加入が必要なSaaSは不可
- 使用量に応じた従量課金のみ

**背景**:

- プロジェクト初期段階では、コストを最小限に抑えたい
- 使用量に応じた課金により、無駄なコストを避けたい

**優先度**: **必須**

---

#### 要件4: IaaSなどメンテナンスが容易かつ、インフラ構成を資産として管理できること

**要求内容**:

- Infrastructure as Code（Terraform、CloudFormation等）が使用可能であること
- メンテナンスが容易であること
- 構成のバージョン管理が可能であること

**背景**:

- インフラ構成をコード化することで、再現性と保守性を向上させる
- チーム内でインフラ構成を共有・管理しやすくする

**優先度**: **必須**

---

### 非機能要件

#### 要件5: コスト効率

**要求内容**:

- 無料枠内なら$0/月で運用可能であること
- 無料枠超過時も低コスト（月$1以下）であること

**優先度**: **高**

---

#### 要件6: パフォーマンス

**要求内容**:

- 初回アクセス時の遅延は許容範囲内（10秒以内）であること
- 2回目以降のアクセスは高速（1秒以内）であること

**優先度**: **中**

---

#### 要件7: 可用性

**要求内容**:

- 高可用性を確保すること
- データ損失のリスクを最小限に抑えること

**優先度**: **高**

---

## 決定事項

### デプロイ方式の決定

#### 決定1: GCP構成の採用

**決定内容**:

- **フロントエンド**: GitHub Pages（無料、静的ホスティング）
- **バックエンド**: GCP Cloud Run（サーバーレス、従量課金）
- **データベース**: GCP Cloud Storage + Cloud Storage API経由の実装

**決定理由**:

1. **コスト効率**: GCPが最もコスト効率が良い（特にCloud Run）
2. **SQLiteとの相性**: Cloud Storage API経由でSQLiteファイルの保存に適している
3. **スケーラビリティ**: Cloud Runは自動スケーリング、リクエスト数に応じた従量課金
4. **メンテナンス性**: Terraformでインフラ構成をコード化可能
5. **CI/CD**: GitHub Actionsで自動デプロイ可能
6. **データ永続化**: Cloud Storage API経由でAPIコンテナとは独立したストレージ管理

**決定日**: 2025-01-XX  
**決定者**: Eng, PdM

---

#### 決定2: Cloud Storage API経由の実装

**決定内容**:

- Cloud Runでは直接的なFUSEマウント（CSIドライバー）がサポートされていないため、Cloud Storage API経由でSQLiteファイルを読み書きする方式を採用

**実装方針**:

1. **起動時**: Cloud StorageからSQLiteファイルをダウンロード → 一時ストレージ（`/tmp`）に保存
2. **処理中**: 一時ストレージのSQLiteファイルを操作
3. **終了時**: 一時ストレージのSQLiteファイルをCloud Storageにアップロード

**決定理由**:

- Cloud Runで確実に動作する
- データ永続化が保証される
- コストが低い（Cloud Storage APIの呼び出しは無料枠内）

**決定日**: 2025-01-XX  
**決定者**: Eng

---

#### 決定3: 同時実行数の制限

**決定内容**:

- Cloud Runの同時実行数を1に制限（`container_concurrency = 1`）

**決定理由**:

- SQLiteは同時書き込みに弱いため、同時実行数を制限することでロック競合を回避
- 小規模利用なら十分なパフォーマンス

**決定日**: 2025-01-XX  
**決定者**: Eng

---

#### 決定4: 変更検知アップロードの実装

**決定内容**:

- データベースに変更があった場合のみCloud Storageにアップロードする
- 読み取り専用のリクエストではアップロードしない

**決定理由**:

- Cloud Storage APIのオペレーション料金を約90%削減可能
- 小規模利用: $0.48/月 → $0.05/月
- 中規模利用: $4.98/月 → $0.50/月

**決定日**: 2025-01-XX  
**決定者**: Eng, PdM

**優先度**: **必須**

---

#### 決定5: バッチアップロードの実装

**決定内容**:

- 複数の変更をまとめてアップロードする
- 例: 10リクエストごとに1回アップロード

**決定理由**:

- さらにコストを削減可能
- パフォーマンスへの影響も最小限

**決定日**: 2025-01-XX  
**決定者**: Eng, PdM

**優先度**: **推奨**

---

#### 決定6: コールドスタートの必須化（コスト制約）

**決定内容**:

- Cloud Runの最小インスタンス数を0に設定（コールドスタートを必須とする）

**決定理由**:

- **コスト制約**: 最小インスタンス数1に設定すると、Cloud Runのコストが約$5-10/月増加する
- **要件適合**: 従量課金制の要件を満たすため、リクエスト時のみ起動する方式を採用
- **許容可能**: 初回アクセス時の遅延（5-10秒程度）は許容範囲内と判断

**影響**:

- 初回アクセス時にコールドスタートが発生（5-10秒程度の遅延）
- Cloud Storageからのダウンロード時間も含めて、初回リクエストの応答時間が遅延する可能性
- 2回目以降のアクセスは高速（一時ストレージから読み込み）

**決定日**: 2025-01-XX  
**決定者**: Eng, PdM

**優先度**: **必須**（コスト制約による）

---

## 機能要件

### データベース永続化機能

#### 機能1: Cloud Storageからのダウンロード

**機能概要**:

- Cloud Run起動時に、Cloud StorageからSQLiteファイルをダウンロードする

**詳細仕様**:

- ダウンロード先: `/tmp/daily-report.db`
- ファイルが存在しない場合は新規作成
- エラーハンドリングを実装

**入力**:

- Cloud Storageバケット名（環境変数: `GCS_BUCKET_NAME`）
- SQLiteファイル名（`daily-report.db`）

**出力**:

- 一時ストレージにSQLiteファイルが保存される

**エラー処理**:

- ダウンロード失敗時はエラーログを出力し、新規ファイルを作成

---

#### 機能2: 変更検知アップロード

**機能概要**:

- データベースに変更があった場合のみ、Cloud Storageにアップロードする

**詳細仕様**:

- データベース操作（INSERT, UPDATE, DELETE）時に変更フラグを立てる
- リクエスト処理後に変更フラグを確認し、変更がある場合のみアップロード
- アップロードは非同期で実行（リクエスト処理をブロックしない）

**実装方針**:

```typescript
let hasChanges = false;

// データベース操作時にフラグを立てる
function markAsChanged() {
  hasChanges = true;
}

// リクエスト処理後
app.use(async (req, res, next) => {
  await next();
  if (hasChanges) {
    syncDatabasePeriodically();
    hasChanges = false;
  }
});
```

**優先度**: **必須**

---

#### 機能3: バッチアップロード

**機能概要**:

- 複数の変更をまとめてアップロードする

**詳細仕様**:

- 変更回数をカウント
- 一定回数（例: 10回）に達したらアップロード
- または、一定時間（例: 5分）経過後にアップロード

**実装方針**:

```typescript
let changeCount = 0;
const BATCH_SIZE = 10;

app.use(async (req, res, next) => {
  await next();
  if (hasChanges) {
    changeCount++;
    if (changeCount >= BATCH_SIZE) {
      syncDatabasePeriodically();
      changeCount = 0;
      hasChanges = false;
    }
  }
});
```

**優先度**: **推奨**

---

#### 機能4: 終了時の確実な同期

**機能概要**:

- Cloud Run終了時に、必ずCloud Storageにアップロードする

**詳細仕様**:

- SIGTERM/SIGINTシグナルをハンドリング
- 終了前に必ずアップロードを実行
- SQLiteのWALファイルとSHMファイルも含めてアップロード

**実装方針**:

```typescript
process.on("SIGTERM", async () => {
  await syncDatabase();
  process.exit(0);
});

process.on("SIGINT", async () => {
  await syncDatabase();
  process.exit(0);
});
```

**優先度**: **必須**

---

### CI/CD機能

#### 機能5: 自動デプロイ

**機能概要**:

- GitHubのmasterブランチにマージされたら、自動的にFE, BEともにデプロイする

**詳細仕様**:

- GitHub Actionsワークフローで実装
- フロントエンド: GitHub Pagesへデプロイ
- バックエンド: Cloud Runへデプロイ

**優先度**: **必須**

---

### インフラ管理機能

#### 機能6: Infrastructure as Code

**機能概要**:

- Terraformでインフラ構成をコード化する

**詳細仕様**:

- Cloud Run、Cloud Storage、Secret Managerの設定をTerraformで管理
- バージョン管理が可能

**優先度**: **必須**

---

## 非機能要件

### パフォーマンス要件

#### 要件1: レスポンスタイム

- 初回アクセス時: 10秒以内（コールドスタート + ダウンロード時間を含む）
- 2回目以降: 1秒以内

#### 要件2: スループット

- 小規模利用: 月10万リクエストまで対応
- 中規模利用: 月100万リクエストまで対応

---

### 可用性要件

#### 要件1: データ損失の防止

- 定期的な同期（リクエスト処理後）
- 終了時の確実な同期（シグナルハンドリング）
- バックアップの自動化（推奨: Cloud Schedulerで1日1回）

#### 要件2: 高可用性

- GitHub PagesとCloud Runは高可用性を提供
- 自動スケーリングでトラフィック増加に対応

---

### セキュリティ要件

#### 要件1: 機密情報の管理

- JWT_SECRETはGCP Secret Managerで管理
- 環境変数は適切に管理

#### 要件2: アクセス制御

- Cloud Storageバケットは公開アクセス無効
- Cloud Runのアクセス制御を適切に設定

---

### コスト要件

#### 要件1: 無料枠内での運用

- 小規模利用: 無料枠内なら$0/月
- 無料枠超過時: 月$1以下

#### 要件2: コスト最適化

- 変更検知アップロードにより、Cloud Storage APIのオペレーション料金を約90%削減
- バッチアップロードにより、さらにコストを削減

#### 要件3: コールドスタートの必須化（コスト制約）

**要件内容**:

- **最小インスタンス数を0に設定し、コールドスタートを必須とする**
- 最小インスタンス数1に設定すると、Cloud Runのコストが約$5-10/月増加するため、採用しない

**理由**:

- 従量課金制の要件を満たすため、リクエスト時のみ起動する方式を採用
- 無料枠内での運用を優先し、コストを最小限に抑える

**影響**:

- 初回アクセス時にコールドスタートが発生（5-10秒程度の遅延）
- パフォーマンスの一部を犠牲にして、コスト効率を優先

**優先度**: **必須**（コスト制約による）

---

## 制約事項

### 技術的制約

#### 制約1: Cloud Runの制約

- Cloud Runでは直接的なFUSEマウント（CSIドライバー）がサポートされていない
- 一時ストレージ（ephemeral storage）のみ使用可能

#### 制約2: SQLiteの制約

- SQLiteは同時書き込みに弱い
- 同時実行数を1に制限する必要がある

#### 制約3: Cloud Storage APIの制約

- オペレーション料金が発生する（無料枠: クラスA 5,000回/月、クラスB 50,000回/月）
- 変更検知アップロードによりコストを削減する必要がある

---

### 運用上の制約

#### 制約1: コールドスタートの必須化（コスト制約）

**制約内容**:

- **コスト制約により、最小インスタンス数を0に設定する必要がある**
- 最小インスタンス数1に設定すると、Cloud Runのコストが約$5-10/月増加する
- 従量課金制の要件を満たすため、リクエスト時のみ起動する方式を採用

**影響**:

- 初回アクセス時にコールドスタートが発生（5-10秒程度の遅延）
- Cloud Storageからのダウンロード時間も含めて、初回リクエストの応答時間が遅延する可能性
- 2回目以降のアクセスは高速（一時ストレージから読み込み）

**許容理由**:

- 小規模利用では、初回アクセス時の遅延は許容範囲内と判断
- コスト効率を優先し、パフォーマンスの一部を犠牲にする

**優先度**: **必須**（コスト制約による）

---

#### 制約2: 同時書き込みの制約

- `container_concurrency = 1`により、スループットが制限される
- 小規模利用なら十分だが、大規模利用時はCloud SQLへの移行を検討

---

## 成功指標

### 機能的な成功指標

#### KPI1: データ永続化の成功率

- **目標**: 99.9%以上
- **測定方法**: データ損失の発生回数を監視

#### KPI2: デプロイ成功率

- **目標**: 99%以上
- **測定方法**: CI/CDパイプラインの成功率を監視

---

### パフォーマンス的な成功指標

#### KPI3: レスポンスタイム

- **目標**: 初回アクセス時10秒以内、2回目以降1秒以内
- **測定方法**: Cloud Runのレスポンスタイムを監視

#### KPI4: スループット

- **目標**: 月100万リクエストまで対応
- **測定方法**: Cloud Runのリクエスト数を監視

---

### コスト的な成功指標

#### KPI5: 月額コスト

- **目標**: 小規模利用: $0.05/月以下、中規模利用: $0.50/月以下
- **測定方法**: Cloud Billingでコストを監視

#### KPI6: コスト最適化率

- **目標**: 変更検知アップロードにより、Cloud Storage APIのオペレーション料金を90%削減
- **測定方法**: Cloud Storage APIのオペレーション回数を監視

---

## バックログ

### 優先度: 高

#### バックログ1: APIリクエスト時のロード体験の改善

**背景**:

- 本仕様により、初回アクセス時にコールドスタートが発生し、約10秒程度のロード時間が発生することが確実
- Cloud Storageからのダウンロード時間も含めて、初回リクエストの応答時間が遅延する可能性がある
- ユーザー体験を向上させるため、ローディング状態を適切に表示する必要がある

**要求内容**:

- APIリクエスト時にローディングインジケーターを表示する
- 初回アクセス時の遅延をユーザーに分かりやすく伝える
- タイムアウト処理を実装する（例: 15秒でタイムアウト）

**想定される実装**:

- フロントエンド: ローディングスピナーやプログレスバーの表示
- エラーハンドリング: タイムアウト時の適切なエラーメッセージ表示
- UX改善: 「初回アクセス時は少し時間がかかります」などのメッセージ表示

**優先度**: **高**

**関連する決定事項**:

- [決定6: コールドスタートの必須化（コスト制約）](#決定6-コールドスタートの必須化コスト制約)

**関連する制約事項**:

- [制約1: コールドスタートの必須化（コスト制約）](#制約1-コールドスタートの必須化コスト制約)

---

### 優先度: 中

#### バックログ2: パフォーマンスモニタリングの実装

**背景**:

- コールドスタートの発生頻度やレスポンスタイムを監視する必要がある
- パフォーマンスの劣化を早期に検知する

**要求内容**:

- Cloud Runのレスポンスタイムを監視
- コールドスタートの発生回数を追跡
- パフォーマンスダッシュボードの作成

**優先度**: **中**

---

### 優先度: 低

#### バックログ3: ウォームアップ機能の検討

**背景**:

- コールドスタートの遅延を軽減するため、定期的にウォームアップリクエストを送信する方法を検討

**要求内容**:

- Cloud Schedulerを使用して定期的にヘルスチェックエンドポイントにリクエストを送信
- コストとのトレードオフを検討（最小インスタンス数1と比較）

**注意事項**:

- コストが発生する可能性がある（Cloud Schedulerの呼び出し料金）
- 効果を測定してから実装を判断

**優先度**: **低**

---

## 付録

### 参考資料

- [デプロイ方式決定書](./deployment_decision.md)
- [技術仕様書](./tech_spec.md)
- [実装計画書](./implement_plan.md)
- [PdMレビュー](./pdm_review.md)
- [Engの技術的回答](./eng_response_to_pdm.md)
- [コスト分析](./eng_cost_analysis_storage_api.md)

---

**最終更新日**: 2025-01-XX
