# データ永続化機能 Helperレビュー：移行コストとSQLiteの限界分析

**作成日**: 2025-12-17  
**作成者**: Helper  
**対象**: PdM, Eng  
**目的**: SQLite採用判断の妥当性を移行コストとSQLiteの限界の観点から検証

---

## 1. 要約と結論

### 1.1 結論

**SQLite採用は現時点では適切な判断**と判断します。ただし、以下の条件を満たす場合に限ります：

1. **本番環境への展開時期が未定**（現状の通り）
2. **開発環境での即座の改善が最優先**（現状の通り）
3. **将来的なPostgreSQL移行を前提とした設計**（抽象化レイヤーの維持）

**ただし、以下の場合はPostgreSQLを最初から採用すべき**：

- 本番環境への展開が**6ヶ月以内**に確定している
- **複数開発者による同時開発**が必須
- **組織展開（複数ユーザー）**が早期に必要

---

## 2. 移行コストの分析

### 2.1 SQLite → PostgreSQLの移行コスト

#### 2.1.1 技術的移行コスト

**低コスト要因**：

1. **SQL互換性**
   - SQLiteとPostgreSQLは標準SQLに準拠
   - 基本的なCRUD操作はそのまま移行可能
   - JOIN、集計関数、インデックスなども互換性が高い

2. **既存の抽象化レイヤー**
   - 現在の設計では、データベースクラスのインターフェースを維持
   - 実装のみを変更すればよい設計になっている
   - 例：`UsersDatabase.save()` のインターフェースは変更不要

3. **スキーマの互換性**
   - テーブル定義はほぼそのまま移行可能
   - UUID、TEXT型などはそのまま使用可能
   - 外部キー制約も同様に定義可能

**中コスト要因**：

1. **SQL方言の違い**
   - SQLite: `INSERT OR REPLACE` → PostgreSQL: `INSERT ... ON CONFLICT`
   - SQLite: `TEXT` → PostgreSQL: `VARCHAR` または `TEXT`（互換性あり）
   - 日付関数の違い（SQLite: `datetime()` → PostgreSQL: `NOW()`）

2. **接続管理の変更**
   - SQLite: ファイルベース（同期API）
   - PostgreSQL: サーバーベース（非同期API）
   - 接続プールの実装が必要

3. **トランザクション処理**
   - SQLite: 同期トランザクション
   - PostgreSQL: 非同期トランザクション（Promise/async-await対応が必要）

**推定工数**：

- **小規模移行**（1-2テーブル）: 2-4時間
- **中規模移行**（5-8テーブル）: 1-2日
- **大規模移行**（10テーブル以上）: 3-5日

**現在のプロジェクト規模**（8テーブル）: **1-2日程度**

#### 2.1.2 データ移行コスト

**開発環境の場合**：

- データ移行は不要（新規データベースを使用）
- **コスト: ほぼゼロ**

**本番環境の場合**：

- SQLiteファイルからPostgreSQLへのデータエクスポート/インポート
- データ整合性の確認
- **コスト: 0.5-1日**（データ量による）

#### 2.1.3 テスト・検証コスト

- 既存テストの修正（データベース接続部分）
- 統合テストの再実行
- **コスト: 1-2日**

**総移行コスト（SQLite → PostgreSQL）**: **2.5-5日程度**

---

### 2.2 PostgreSQLを最初から採用する場合のコスト

#### 2.2.1 初期セットアップコスト

**開発環境のセットアップ**：

1. **PostgreSQLサーバーのセットアップ**
   - Docker Composeの設定: 0.5-1時間
   - データベース作成・ユーザー設定: 0.5時間
   - 接続設定: 0.5時間
   - **合計: 1.5-2時間**

2. **ライブラリの選定・導入**
   - `pg` または `pg-promise` の選定: 0.5時間
   - 依存関係の追加: 0.5時間
   - **合計: 1時間**

3. **接続管理の実装**
   - 接続プールの実装: 2-4時間
   - エラーハンドリング: 1-2時間
   - **合計: 3-6時間**

4. **非同期APIへの対応**
   - 既存の同期コードを非同期に変更: 4-8時間
   - Promise/async-awaitの導入: 2-4時間
   - **合計: 6-12時間**

**初期セットアップ総コスト**: **11.5-21時間（1.5-2.5日）**

#### 2.2.2 開発効率への影響

**PostgreSQL採用のデメリット**：

1. **開発環境の複雑化**
   - Dockerの起動が必要（SQLiteは不要）
   - サーバーの管理が必要
   - 開発者のセットアップ手順が増える

2. **CI/CDの複雑化**
   - PostgreSQLコンテナの起動が必要
   - テスト環境のセットアップが複雑

3. **デバッグの困難さ**
   - サーバーログの確認が必要
   - 接続エラーのトラブルシューティングが複雑

**推定コスト**: **継続的な開発効率の低下（10-20%程度）**

#### 2.2.3 総コスト比較

| 項目                          | SQLite採用 | PostgreSQL採用               |
| ----------------------------- | ---------- | ---------------------------- |
| 初期セットアップ              | 0.5-1日    | 1.5-2.5日                    |
| 開発効率への影響              | なし       | 継続的な低下（10-20%）       |
| 将来の移行コスト              | 2.5-5日    | 0日                          |
| **総コスト（1年後移行想定）** | **3-6日**  | **1.5-2.5日 + 継続的コスト** |

**結論**:

- **短期（6ヶ月以内）**: PostgreSQL採用が有利
- **中期（6ヶ月-1年）**: SQLite採用が有利
- **長期（1年以上）**: SQLite採用が有利（移行コスト < 継続的コスト）

---

## 3. SQLiteの限界（分水嶺）

### 3.1 同時書き込みの制限

#### 3.1.1 技術的制限

**SQLiteの同時書き込み**：

- **デフォルト**: 1つの書き込みトランザクションのみ
- **WALモード**: 複数の読み取り + 1つの書き込み（推奨）
- **実用的な同時書き込み数**: **1-2個**（WALモード使用時）

**PostgreSQLの同時書き込み**：

- **理論的制限**: ほぼ無制限（接続プールサイズによる）
- **実用的な同時書き込み数**: **100-1000個以上**

#### 3.1.2 分水嶺の判断基準

**SQLiteで問題になる場合**：

1. **複数開発者による同時開発**
   - 2人以上の開発者が同時にAPIを呼び出す
   - テスト実行中に開発サーバーを起動する
   - **分水嶺: 2-3人の同時開発者**

2. **複数ユーザーによる同時利用**
   - 本番環境で複数ユーザーが同時に日報を保存する
   - **分水嶺: 5-10人の同時アクティブユーザー**

3. **バックグラウンドジョブ**
   - 定期的なデータ処理ジョブが実行される
   - **分水嶺: 1つのバックグラウンドジョブ + ユーザーリクエスト**

**現在のプロジェクト**：

- 開発環境: 1人の開発者が主に使用
- 本番環境: 未展開
- **現状では問題なし**

---

### 3.2 データサイズの制限

#### 3.2.1 技術的制限

**SQLiteの制限**：

- **最大データベースサイズ**: 約140TB（理論値）
- **実用的なサイズ**: 10-100GB程度（パフォーマンス考慮）
- **推奨サイズ**: 1GB以下（最適パフォーマンス）

**PostgreSQLの制限**：

- **最大データベースサイズ**: 32TB（理論値、実装による）
- **実用的なサイズ**: 数TB以上も可能

#### 3.2.2 分水嶺の判断基準

**SQLiteで問題になる場合**：

1. **大量のデータ蓄積**
   - 日報データが10万件以上（約1-2GB）
   - **分水嶺: 10-50万件の日報データ**

2. **大容量のファイル保存**
   - 画像やファイルをデータベースに保存する
   - **分水嶺: 1GB以上のファイル保存**

**現在のプロジェクト**：

- 日報データ: テキストベース（1件あたり数KB）
- 10万件で約500MB-1GB程度
- **現状では問題なし（数年は持つ）**

---

### 3.3 パフォーマンスの限界

#### 3.3.1 読み取りパフォーマンス

**SQLite**：

- **単一クエリ**: 非常に高速（インデックス使用時）
- **複雑なJOIN**: 中規模データ（10万件以下）で高速
- **集計クエリ**: 中規模データで高速

**PostgreSQL**：

- **単一クエリ**: 高速（インデックス使用時）
- **複雑なJOIN**: 大規模データでも高速
- **集計クエリ**: 大規模データでも高速

#### 3.3.2 書き込みパフォーマンス

**SQLite**：

- **単一書き込み**: 非常に高速
- **バッチ書き込み**: 高速（トランザクション使用時）
- **同時書き込み**: 制限あり（WALモードで改善）

**PostgreSQL**：

- **単一書き込み**: 高速
- **バッチ書き込み**: 高速
- **同時書き込み**: 高いスループット

#### 3.3.3 分水嶺の判断基準

**SQLiteで問題になる場合**：

1. **複雑なクエリの実行時間**
   - 10秒以上のクエリが頻繁に発生
   - **分水嶺: 100万件以上のデータ + 複雑なJOIN**

2. **リアルタイム処理**
   - 1秒以内の応答が必要な処理
   - **分水嶺: 10万件以上のデータ + リアルタイム要件**

**現在のプロジェクト**：

- 日報データ: テキストベース、シンプルなクエリ
- ユーザー数: 少数（開発環境）
- **現状では問題なし**

---

### 3.4 スケーラビリティの限界

#### 3.4.1 水平スケーリング

**SQLite**：

- **水平スケーリング**: 不可能（単一ファイル）
- **レプリケーション**: 不可能

**PostgreSQL**：

- **水平スケーリング**: 可能（レプリケーション、シャーディング）
- **レプリケーション**: 可能（読み取りレプリカ）

#### 3.4.2 分水嶺の判断基準

**SQLiteで問題になる場合**：

1. **複数サーバーでの運用**
   - ロードバランサーで複数インスタンスを運用
   - **分水嶺: 2台以上のサーバー**

2. **高可用性の要件**
   - 99.9%以上の可用性が必要
   - **分水嶺: 本番環境での運用**

**現在のプロジェクト**：

- 開発環境: 単一サーバー
- 本番環境: 未展開
- **現状では問題なし**

---

## 4. プロジェクトの現状を考慮した判断

### 4.1 プロジェクトの特徴

1. **Zero to Oneフェーズ**
   - プロダクトの最初期段階
   - 要件や仕様が頻繁に変わる
   - 変更容易性が最優先

2. **開発環境優先**
   - 本番環境への展開時期が未定
   - 開発効率の向上が最優先

3. **小規模なデータ**
   - 日報データはテキストベース
   - ユーザー数は少数（開発環境）

### 4.2 SQLite採用の妥当性

**適切な理由**：

1. **開発環境での即座の改善**
   - データ永続化を簡単に実現
   - セットアップが簡単（ファイルベース）

2. **変更容易性**
   - 将来的な移行が容易（SQL互換性）
   - 既存コードへの影響が最小限

3. **現状の要件を満たす**
   - 同時書き込み: 問題なし（1人開発）
   - データサイズ: 問題なし（小規模データ）
   - パフォーマンス: 問題なし（シンプルなクエリ）

**リスク**：

1. **本番環境への移行時期が早い場合**
   - 6ヶ月以内に移行が必要なら、PostgreSQLを最初から採用すべき

2. **複数開発者による同時開発**
   - 2人以上の開発者が同時に開発する場合、PostgreSQLを検討すべき

---

## 5. 推奨事項

### 5.1 現時点での判断

**SQLite採用を推奨**します。理由：

1. **本番環境への展開時期が未定**
2. **開発環境での即座の改善が最優先**
3. **移行コストが低い（2.5-5日程度）**
4. **現状の要件を満たす**

### 5.2 移行タイミングの判断基準

以下の条件のいずれかを満たす場合、PostgreSQLへの移行を検討：

1. **本番環境への展開が6ヶ月以内に確定**
2. **複数開発者（2-3人以上）による同時開発が必須**
3. **本番環境で複数ユーザー（5-10人以上）による同時利用が想定**
4. **データ量が10万件を超える見込み**

### 5.3 移行を容易にするための設計

以下の設計を維持することで、移行コストを最小化：

1. **データベースクラスのインターフェース維持**
   - `save()`, `findById()` などのメソッドシグネチャを維持
   - 実装のみを変更可能にする

2. **SQL互換性の維持**
   - 標準SQLを使用（SQLite固有の機能を避ける）
   - PostgreSQLでも動作するSQLを書く

3. **抽象化レイヤーの維持**
   - データベース接続を抽象化
   - 実装の詳細を隠蔽

---

## 6. リスクと対策

### 6.1 リスク

1. **本番環境への移行時期が早まる**
   - **対策**: 移行コストを低く抑える設計を維持

2. **SQLiteの限界に達する**
   - **対策**: 定期的な監視と移行タイミングの判断

3. **移行時のダウンタイム**
   - **対策**: 段階的な移行戦略の策定

### 6.2 対策

1. **移行準備**
   - PostgreSQLへの移行手順をドキュメント化
   - 移行スクリプトの準備

2. **監視**
   - データサイズの監視
   - パフォーマンスの監視
   - 同時書き込みの監視

3. **段階的な移行**
   - 開発環境でPostgreSQLを試す
   - 本番環境への段階的な移行

---

## 7. まとめ

### 7.1 移行コストのまとめ

| 項目                          | SQLite採用 | PostgreSQL採用               |
| ----------------------------- | ---------- | ---------------------------- |
| 初期セットアップ              | 0.5-1日    | 1.5-2.5日                    |
| 開発効率への影響              | なし       | 継続的な低下（10-20%）       |
| 将来の移行コスト              | 2.5-5日    | 0日                          |
| **総コスト（1年後移行想定）** | **3-6日**  | **1.5-2.5日 + 継続的コスト** |

### 7.2 SQLiteの限界（分水嶺）

| 項目             | 分水嶺              | 現在のプロジェクト |
| ---------------- | ------------------- | ------------------ |
| 同時書き込み     | 2-3人の同時開発者   | 1人（問題なし）    |
| データサイズ     | 10-50万件           | 少数（問題なし）   |
| パフォーマンス   | 100万件以上のデータ | 少数（問題なし）   |
| スケーラビリティ | 2台以上のサーバー   | 1台（問題なし）    |

### 7.3 最終判断

**SQLite採用は現時点では適切な判断**です。

ただし、以下の条件を満たす場合はPostgreSQLを最初から採用すべき：

1. 本番環境への展開が**6ヶ月以内**に確定している
2. **複数開発者（2-3人以上）**による同時開発が必須
3. **組織展開（複数ユーザー）**が早期に必要

**推奨**: 現状のSQLite採用を継続し、移行タイミングの判断基準を定期的にレビューする。

---

**ステータス**: Approved（条件付き）  
**次回レビュー予定**: 本番環境への展開時期が確定した時点
